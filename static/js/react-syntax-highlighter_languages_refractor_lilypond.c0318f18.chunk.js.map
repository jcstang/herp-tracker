{"version":3,"sources":["../node_modules/refractor/lang/scheme.js","../node_modules/refractor/lang/lilypond.js"],"names":["scheme","Prism","languages","comment","string","pattern","greedy","symbol","character","alias","lookbehind","keyword","builtin","number","boolean","operator","function","punctuation","module","exports","displayName","aliases","refractorScheme","require","lilypond","register","schemeExpression","source","i","replace","RegExp","inside","rest","ly"],"mappings":"4HAKA,SAASA,EAAOC,GACdA,EAAMC,UAAUF,OAAS,CACvBG,QAAS,MACTC,OAAQ,CACNC,QAAS,oBACTC,QAAQ,GAEVC,OAAQ,CACNF,QAAS,cACTC,QAAQ,GAEVE,UAAW,CACTH,QAAS,uCACTC,QAAQ,EACRG,MAAO,UAET,mBAAoB,CAElB,CACEJ,QAAS,yBACTK,YAAY,GAEd,CACEL,QAAS,yBACTK,YAAY,IAGhBC,QAAS,CACPN,QAAS,gPACTK,YAAY,GAEdE,QAAS,CACPP,QAAS,4NACTK,YAAY,GAEdG,OAAQ,CAgBNR,QAAS,uVACTK,YAAY,GAEdI,QAAS,CACPT,QAAS,8BACTK,YAAY,GAEdK,SAAU,CACRV,QAAS,0CACTK,YAAY,GAEdM,SAAU,CACRX,QAAS,4BACTK,YAAY,GAEdO,YAAa,SArEjBC,EAAOC,QAAUnB,EACjBA,EAAOoB,YAAc,SACrBpB,EAAOqB,QAAU,I,iCCHjB,IAAIC,EAAkBC,EAAQ,KAI9B,SAASC,EAASvB,GAChBA,EAAMwB,SAASH,GACd,SAAWrB,GAKV,IAJA,IAAIyB,EAAmB,mGACpBC,OAGMC,EAAI,EAAGA,EADQ,EACeA,IACrCF,EAAmBA,EAAiBG,QAAQ,WAAW,WACrD,OAAOH,KAGXA,EAAmBA,EAAiBG,QAAQ,UAAW,UAAUF,QACjE,IAAIH,EAAYvB,EAAMC,UAAUsB,SAAW,CACzCrB,QAAS,8BACT,kBAAmB,CACjBE,QAASyB,OACP,8DAA8DH,OAAOE,QACnE,WACA,WACE,OAAOH,KAGX,KAEFhB,YAAY,EACZJ,QAAQ,EACRyB,OAAQ,CACN/B,OAAQ,CACNK,QAAS,eACTK,YAAY,EACZD,MAAO,kBACPsB,OAAQ,CACN,oBAAqB,CACnB1B,QAAS,iBACTC,QAAQ,EACRyB,OAAQ,CACNd,YAAa,YACbO,SAAU,CACRnB,QAAS,UACTI,MAAO,oBACPsB,OAAQ,QAIdC,KAAM/B,EAAMC,UAAUF,SAG1BiB,YAAa,MAGjBb,OAAQ,CACNC,QAAS,oBACTC,QAAQ,GAEV,aAAc,CACZD,QAAS,mBACTK,YAAY,GAEdC,QAAS,CACPN,QAAS,iBACT0B,OAAQ,CACNd,YAAa,QAGjBF,SAAU,aACVE,YAAa,CACXZ,QAAS,uGACTK,YAAY,GAEdG,OAAQ,qBAEVW,EAAS,mBAAmBO,OAA5B,OAA6CA,OAC3C,qBACAA,OAFF,SAEqBA,OAASP,EAC9BvB,EAAMC,UAAU+B,GAAKT,EAzEtB,CA0EEvB,GA/ELiB,EAAOC,QAAUK,EACjBA,EAASJ,YAAc,WACvBI,EAASH,QAAU","file":"static/js/react-syntax-highlighter_languages_refractor_lilypond.c0318f18.chunk.js","sourcesContent":["'use strict'\n\nmodule.exports = scheme\nscheme.displayName = 'scheme'\nscheme.aliases = []\nfunction scheme(Prism) {\n  Prism.languages.scheme = {\n    comment: /;.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true\n    },\n    symbol: {\n      pattern: /'[^()#'\\s]+/,\n      greedy: true\n    },\n    character: {\n      pattern: /#\\\\(?:[ux][a-fA-F\\d]+|[-a-zA-Z]+|\\S)/,\n      greedy: true,\n      alias: 'string'\n    },\n    'lambda-parameter': [\n      // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30\n      {\n        pattern: /(\\(lambda\\s+)[^()'\\s]+/,\n        lookbehind: true\n      },\n      {\n        pattern: /(\\(lambda\\s+\\()[^()']+/,\n        lookbehind: true\n      }\n    ],\n    keyword: {\n      pattern: /(\\()(?:define(?:-library|-macro|-syntax|-values)?|defmacro|(?:case-)?lambda|let(?:(?:\\*|rec)?(?:-values)?|-syntax|rec-syntax)|else|if|cond|begin|delay(?:-force)?|parameterize|guard|set!|(?:quasi-)?quote|syntax-(?:case|rules))(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    builtin: {\n      pattern: /(\\()(?:(?:cons|car|cdr|list|call-with-current-continuation|call\\/cc|append|abs|apply|eval)\\b|null\\?|pair\\?|boolean\\?|eof-object\\?|char\\?|procedure\\?|number\\?|port\\?|string\\?|vector\\?|symbol\\?|bytevector\\?)(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    number: {\n      // This pattern (apart from the lookarounds) works like this:\n      //\n      // Decimal numbers\n      // <dec real>       := \\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+\n      // <dec complex>    := <dec real>(?:[+-]<dec real>i)?|<dec real>i\n      // <dec prefix>     := (?:#d(?:#[ei])?|#[ei](?:#d)?)?\n      // <dec number>     := <dec prefix>[+-]?<complex>\n      //\n      // Binary, octal, and hexadecimal numbers\n      // <b.o.x. real>    := [\\da-fA-F]+(?:\\/[\\da-fA-F]+)?\n      // <b.o.x. complex> := <b.o.x. real>(?:[+-]<b.o.x. real>i)?|<b.o.x. real>i\n      // <b.o.x. prefix>  := #[box](?:#[ei])?|#[ei](?:#[box])?\n      // <b.o.x. number>  := <b.o.x. prefix>[+-]?<b.o.x. complex>\n      //\n      // <number>         := <dec number>|<b.o.x. number>\n      pattern: /(^|[\\s()])(?:(?:#d(?:#[ei])?|#[ei](?:#d)?)?[+-]?(?:(?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)(?:[+-](?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)i)?|(?:\\d*\\.?\\d+(?:[eE][+-]?\\d+)?|\\d+\\/\\d+)i)|(?:#[box](?:#[ei])?|#[ei](?:#[box])?)[+-]?(?:[\\da-fA-F]+(?:\\/[\\da-fA-F]+)?(?:[+-][\\da-fA-F]+(?:\\/[\\da-fA-F]+)?i)?|[\\da-fA-F]+(?:\\/[\\da-fA-F]+)?i))(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    boolean: {\n      pattern: /(^|[\\s()])#[ft](?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    operator: {\n      pattern: /(\\()(?:[-+*%\\/]|[<>]=?|=>?)(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    function: {\n      pattern: /(\\()[^()'\\s]+(?=[()\\s]|$)/,\n      lookbehind: true\n    },\n    punctuation: /[()']/\n  }\n}\n","'use strict'\nvar refractorScheme = require('./scheme.js')\nmodule.exports = lilypond\nlilypond.displayName = 'lilypond'\nlilypond.aliases = []\nfunction lilypond(Prism) {\n  Prism.register(refractorScheme)\n  ;(function (Prism) {\n    var schemeExpression = /\\((?:[^();\"#\\\\]|\\\\[\\s\\S]|;.*(?!.)|\"(?:[^\"\\\\]|\\\\.)*\"|#(?:\\{(?:(?!#\\})[\\s\\S])*#\\}|[^{])|<expr>)*\\)/\n      .source // allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions\n    // For some reason, this can't be 4\n    var recursivenessLog2 = 5\n    for (var i = 0; i < recursivenessLog2; i++) {\n      schemeExpression = schemeExpression.replace(/<expr>/g, function () {\n        return schemeExpression\n      })\n    }\n    schemeExpression = schemeExpression.replace(/<expr>/g, /[^\\s\\S]/.source)\n    var lilypond = (Prism.languages.lilypond = {\n      comment: /%(?:(?!\\{).*|\\{[\\s\\S]*?%\\})/,\n      'embedded-scheme': {\n        pattern: RegExp(\n          /(^|[=\\s])#(?:\"(?:[^\"\\\\]|\\\\.)*\"|[^\\s()\"]*(?:[^\\s()]|<expr>))/.source.replace(\n            /<expr>/g,\n            function () {\n              return schemeExpression\n            }\n          ),\n          'm'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          scheme: {\n            pattern: /^(#)[\\s\\S]+$/,\n            lookbehind: true,\n            alias: 'language-scheme',\n            inside: {\n              'embedded-lilypond': {\n                pattern: /#\\{[\\s\\S]*?#\\}/,\n                greedy: true,\n                inside: {\n                  punctuation: /^#\\{|#\\}$/,\n                  lilypond: {\n                    pattern: /[\\s\\S]+/,\n                    alias: 'language-lilypond',\n                    inside: null // see below\n                  }\n                }\n              },\n              rest: Prism.languages.scheme\n            }\n          },\n          punctuation: /#/\n        }\n      },\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': {\n        pattern: /(\\\\new\\s+)[\\w-]+/,\n        lookbehind: true\n      },\n      keyword: {\n        pattern: /\\\\[a-z][-\\w]*/i,\n        inside: {\n          punctuation: /^\\\\/\n        }\n      },\n      operator: /[=|]|<<|>>/,\n      punctuation: {\n        pattern: /(^|[a-z\\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\\d))|[_^]\\.?|[.!])|[{}()[\\]<>^~]|\\\\[()[\\]<>\\\\!]|--|__/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\/\\d+)?\\b/\n    })\n    lilypond['embedded-scheme'].inside['scheme'].inside[\n      'embedded-lilypond'\n    ].inside['lilypond'].inside = lilypond\n    Prism.languages.ly = lilypond\n  })(Prism)\n}\n"],"sourceRoot":""}